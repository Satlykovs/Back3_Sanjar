1. Выполните sql запрос из файла "SQL скрипт".
Напишите следующие запросы:
- запрос для выборки всех заказов с подробной информацией о клиентах и продуктах
- запрос для выборки всех клиентов и их заказов, включая клиентов без заказов
- запрос для выборки всех продуктов и заказов, включая продукты, которые не были заказаныэ
- запрос для выборки всех клиентов и продуктов

2. Напишите следующие запросы:
- запрос для выборки пар продуктов одной категории с разными ценами
- запрос, который вернет список клиентов и общую сумму, которую каждый клиент потратил на все свои заказы. Отобразите только тех клиентов, которые потратили более 100 единиц валюты
- запрос, который выведет всех клиентов, которые еще не сделали ни одного заказа и найдите тех клиентов, у которых нет связанных записей в таблице orders

3. Напишите следующие запросы:
- запрос, который выведет все продукты, которые не были куплены ни в одном заказе и отфильтруйте результаты, чтобы показать только те продукты, которые не имеют связанных записей в order_details
- запрос, который вернет полный список всех клиентов и продуктов, независимо от того, сделали ли клиенты заказы или были ли проданы продукты. Поскольку SQLite не поддерживает FULL OUTER JOIN, эмулируйте его с помощью UNION ALL для комбинации результатов LEFT JOIN и RIGHT JOIN
- запрос, который найдет все возможные комбинации продуктов для заказа, исключая продукты из категории "Электроника". Используйте CROSS JOIN, чтобы создать полное декартово произведение всех продуктов.   



Дополнение к практике урока 24

Часть 1 (транзакции): 

Создайте две таблицы: 
users с колонками id (INTEGER, PRIMARY KEY), name (TEXT), age (INTEGER). 
 
orders с колонками id (INTEGER, PRIMARY KEY), user_id (INTEGER), amount (INTEGER). 
 
Напишите транзакцию, которая: 
Добавляет пользователя с именем "Alice" и возрастом 25. 
Добавляет для неё заказ на сумму 150. 
Фиксирует изменения.
 
Модифицируйте задание из части A. 
Если пользователь с именем "Alice" уже существует в таблице users, транзакция должна откатываться (используйте ROLLBACK). 
 
Добавьте проверку: если сумма заказа больше 1000, транзакция должна откатиться. 
В противном случае добавьте заказ. 
В конце зафиксируйте изменения. 

Создайте две таблицы: 
 
users с колонками id (INTEGER, PRIMARY KEY), name (TEXT), age (INTEGER). 
orders с колонками id (INTEGER, PRIMARY KEY), user_id (INTEGER), amount (INTEGER), order_date (DATE). 
Напишите транзакцию, которая: 
 
Добавляет пользователя с именем "Alice" и возрастом 25. 
Добавляет заказ для пользователя на сумму 150 с текущей датой. 
Фиксирует изменения. 
 
Модифицируйте задание: 
 
Если пользователь с именем "Alice" уже существует в таблице users, транзакция должна откатываться (используйте ROLLBACK). 
Если сумма всех заказов в таблице orders для этого пользователя превышает 5000, транзакция должна откатываться. 
Если сумма текущего заказа превышает 1000, транзакция также должна откатываться. 
Если дата заказа старше одного года от текущей даты, транзакция должна откатываться. 
Используйте агрегатную функцию (SUM) для проверки общей суммы заказов пользователя. 
В конце успешной транзакции зафиксируйте изменения.

Часть вторая (уровни изоляции):

Каждый из вас может постепенно переходить на какую-то бд (postgre, mysql, oracle и тд), так вот нужно подробнее разобраться с тем, как уровни изоляции устроены конкретно в вашем случае.